package model

import (
	"strings"

	"github.com/ethereum/go-ethereum/core/types"
)

// Transaction is an Ethereum transaction.
type Transaction struct {
	BlockHash string // empty if unconfirmed
	BlockNumber uint64 // empty if unconfirmed

	Hash string `gorm:"primaryKey"`
	Size uint64

	// TxData - Consensus contents of a transaction
	Data []byte
	Gas uint64
	GasPrice string // big int
	Cost uint64
	Nonce uint64
	To string // address
	Value string // big int
}

// ContractEventLog represents a contract log event. These events are generated by the LOG opcode and
// stored/indexed by the node.
type ContractEventLog struct {
	// Consensus fields:
	// address of the contract that generated the event
	Address string `gorm:"index"`
	// list of topics provided by the contract.
	Topics string // []hash
	// supplied by the contract, usually ABI-encoded
	Data []byte

	// Derived fields. These fields are filled in by the node
	// but not secured by consensus.
	// block in which the transaction was included
	BlockNumber uint64
	// hash of the transaction
	TxHash string `gorm:"index:idx_tx_log,priority:1"`
	// index of the transaction in the block
	TxIndex uint
	// hash of the block in which the transaction was included
	BlockHash string `gorm:"index"`
	// index of the log in the block
	Index uint `gorm:"index:idx_tx_log,priority:2"`

	// The Removed field is true if this log was reverted due to a chain reorganisation.
	// You must pay attention to this field if you receive logs through a filter query.
	Removed bool
}

func ConvertClientEventToModelEvent(evt *types.Log) ContractEventLog {
	event := ContractEventLog{
		Address: evt.Address.Hex(),
		Topics: "",
		Data: evt.Data,
		BlockNumber: evt.BlockNumber,
		TxHash: evt.TxHash.Hex(),
		TxIndex: evt.TxIndex,
		BlockHash: evt.BlockHash.Hex(),
		Index: evt.Index,
		Removed: evt.Removed,
	}

	topics := []string{}
	for _, e := range evt.Topics {
		topics = append(topics, e.Hex())
	}
	event.Topics = strings.Join(topics[:], ",")

	return event
}